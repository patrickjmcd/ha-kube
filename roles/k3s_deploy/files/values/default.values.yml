homebridge:
  replicaCount: 1

  image:
    repository: oznu/homebridge
    tag: latest
    pullPolicy: IfNotPresent

  config_ui_port: 8888
  loadbalancer_ip: 192.168.8.201 # IP Address used to define the loadbalancer service

  env:
    - name: UID
      value: "1026"
    - name: GID
      value: "100"
    - name: tz
      value: America/Chicago

  service:
    type: ClusterIP
    port: 80

  ingress:
    enabled: true
    annotations:
      kubernetes.io/ingress.class: nginx
      cert-manager.io/cluster-issuer: "letsencrypt-prod"
      nginx.ingress.kubernetes.io/proxy-body-size: "50m"
    path: /
    hosts:
      - homebridge.pmcd.io
    tls:
      - secretName: homebridge-prod-tls
        hosts:
          - homebridge.pmcd.io

  volumes:
    - name: homebridge
      persistentVolumeClaim:
        claimName: nfs-config-homebridge-claim

  volumeMounts:
    - name: homebridge
      mountPath: "/homebridge"

  resources:
    requests:
      memory: 2048Mi
      cpu: 1
    limits:
      memory: 4096Mi
      cpu: 5

  nodeSelector: {}

  tolerations: []

  affinity: {}
  annotations:
    "consul.hashicorp.com/connect-inject": "true"

ghost:
  replicaCount: 1

  image:
    repository: ghost
    tag: latest
    pullPolicy: IfNotPresent

  service:
    type: ClusterIP
    port: 80

  uid: 1026
  gid: 100

  env:
    - name: url
      value: https://blog.pmcd.io

  ingress:
    enabled: true
    annotations:
      kubernetes.io/ingress.class: nginx
      cert-manager.io/cluster-issuer: "letsencrypt-prod" # Encrypt using the ClusterIssuer deployed while setting up Cert-Manager

    path: /
    hosts:
      - blog.pmcd.io
    tls:
      - secretName: "ghost-prod-tls"
        hosts:
          - blog.pmcd.io

  volumes:
    - name: content
      persistentVolumeClaim:
        claimName: nfs-config-ghost-claim

  volumeMounts:
    - name: content
      mountPath: /var/lib/ghost/content

  resources:
    requests:
      memory: 128Mi
      cpu: 0.1
    limits:
      memory: 256Mi
      cpu: 0.5

  nodeSelector: {}

  tolerations: []

  affinity: {}
  # annotations:
  #   "consul.hashicorp.com/connect-inject": "true"

influxdb:
  ## influxdb image version
  ## ref: https://hub.docker.com/r/library/influxdb/tags/
  image:
    repository: "influxdb"
    tag: "1.8"
    pullPolicy: IfNotPresent

  serviceAccount:
    create: true
    name:
    annotations: {}

  ## Persist data to a persistent volume
  ##
  persistence:
    enabled: true
    existingClaim: nfs-data-influxdb-claim

  setDefaultUser:
    user:
      existingSecret: influxdb-auth

  ## Configure resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  resources:
    requests:
      memory: 256Mi
      cpu: 0.1
    limits:
      memory: 1Gi
      cpu: 1

  # Annotations to be added to InfluxDB pods
  # podAnnotations:
  #   "consul.hashicorp.com/connect-inject": "true"

  ingress:
    enabled: true
    tls: true
    secretName: influxdb-prod-tls
    hostname: influxdb.pmcd.io
    annotations:
      kubernetes.io/ingress.class: nginx
      cert-manager.io/cluster-issuer: "letsencrypt-prod"
      nginx.ingress.kubernetes.io/proxy-body-size: "50m"
    path: /

postgresql:
  ## Bitnami PostgreSQL image version
  ## ref: https://hub.docker.com/r/bitnami/postgresql/tags/
  ##
  image:
    registry: docker.io
    repository: bitnami/postgresql
    tag: 11.9.0-debian-10-r48
    pullPolicy: IfNotPresent
    debug: false

  service:
    type: LoadBalancer
    port: 5432
    annotations: {}
    loadBalancerIP: 192.168.8.203


  postgresqlUsername: postgres
  ## PostgreSQL password using existing secret
  existingSecret: postgresql-secret


  ## PostgreSQL data dir
  ## ref: https://github.com/bitnami/bitnami-docker-postgresql/blob/master/README.md
  ##
  postgresqlDataDir: /bitnami/postgresql/data

  postgresqlDatabase: main

  ## PostgreSQL data Persistent Volume Storage Class
  ## If defined, storageClassName: <storageClass>
  ## If set to "-", storageClassName: "", which disables dynamic provisioning
  ## If undefined (the default) or set to null, no storageClassName spec is
  ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
  ##   GKE, AWS & OpenStack)
  ##
  securityContext:
    enabled: true
    fsGroup: 100

  containerSecurityContext:
    enabled: true
    runAsUser: 1026
  volumePermissions:
    enabled: true
  persistence:
    enabled: true
    ## A manually managed Persistent Volume and Claim
    ## If defined, PVC must be created manually before volume will be bound
    ## The value is evaluated as a template, so, for example, the name can depend on .Release or .Chart
    ##
    existingClaim: nfs-data-postgresql-claim

    ## The path the volume will be mounted at, useful when using different
    ## PostgreSQL images.
    ##
    mountPath: /bitnami/postgresql


  ## updateStrategy for PostgreSQL StatefulSet and its slaves StatefulSets
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
  ##
  updateStrategy:
    type: RollingUpdate

  ##
  ## PostgreSQL Master parameters
  ##
  master:
    ## Node, affinity, tolerations, and priorityclass settings for pod assignment
    ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#nodeselector
    ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
    ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#taints-and-tolerations-beta-feature
    ## ref: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption
    ##
    nodeSelector: 
      beta.kubernetes.io/arch: amd64
    
  ## Configure resource requests and limits
  ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
  ##
  resources:
    requests:
      memory: 256Mi
      cpu: 250m

strapi:
  replicaCount: 1

  image:
      repository: strapi/strapi
      tag: latest
      pullPolicy: IfNotPresent

  env:
      database_client: postgres
      database_port: 5432

  # you must create a secret in the same namespace with the following keys:
  #    - database_host
  #    - database_username
  #    - database_password
  database_secret_name: strapi-secret

  service:
      type: ClusterIP
      port: 80

  ingress:
      enabled: true
      annotations:
          kubernetes.io/ingress.class: nginx
          cert-manager.io/cluster-issuer: "letsencrypt-prod"
          nginx.ingress.kubernetes.io/proxy-body-size: "50m"
      path: /
      hosts:
          - strapi.pmcd.io
      tls:
          - secretName: strapi-prod-tls
            hosts:
                - strapi.pmcd.io

  volumes:
      - name: strapi-volume
        persistentVolumeClaim:
            claimName: nfs-data-strapi-claim

  volumeMounts:
      - name: strapi-volume
        mountPath: "/srv/app"

  resources:
      requests:
          memory: 128Mi
          cpu: 0.1
      limits:
          memory: 256Mi
          cpu: 0.5

  nodeSelector:
    beta.kubernetes.io/arch: amd64

  tolerations: []

  affinity: {}